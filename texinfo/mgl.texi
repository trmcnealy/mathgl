@c ------------------------------------------------------------------
@node MGL interface, Python interface, C interface, Interfaces
@section MGL interface

MathGL library supports (from version 1.3) the simplest scripts for data handling and plotting. These scripts can be used independently (with the help of mgl2png, mgl2eps, mgl2svg programs and others) or in the frame of the library using.

MGL script language is rather simple. Each string is a command. First word of string is the name of command. Other words are command arguments. Command may have up to 1000 arguments (at least for now). Words are separated from each other by space or tabulation symbol. The upper or lower case of words is suficient, i.e. variables a and A are different variables. Symbol @samp{#} starts the comment (all characters after # will be ignored). The exception is situation when # is a part of some string. Also options can be specified at the end of string (after symbol @samp{;}, @pxref{Command options (MGL)}).

If string contain references to external parameters (substrings @samp{$0}, @samp{$1} ... @samp{$9}) then before execution the values of parameter will be substituted instaed of reference. It allows to use the same MGL script for different parameters (filenames, paths, condition and so on).

Argument can be a string, a variable name or a number. 
@itemize @bullet
@item 
The string is any symbols between ordinary marks @samp{'}.

@item 
Variable name is arbitrary combination of symbols (except spaces and @samp{'}) started from a letter and with length less than 64. It is possible to use subarrays (like in subdata command) as command argument. For example, @code{a(1)} or @code{a(1,:)} or @code{a(1,:,:)} is second row, @code{a(:,2)} or @code{a(:,2,:)} is third column, @code{a(:,:,0)} is first slice and so on.

If names for data columns was specified (by set_id command or in the file at string started with @code{##}) then it is possible to use any column combinations defined by formulas, like @code{a('n*w^2/exp(t)')}.

@item 
Special names @code{nan=#QNAN, pi=3.1415926..., on=1, off=0, :=-1} are treated as number if they were not redefined by user. Also variables with suffixes are treated as numbers (@pxref{Suffixes}).
@end itemize
Before the first using all variables must bedefined with the help of commands, like, @code{new, var, list, copy} or @code{read}. 

All MGL commands can be divided on several groups. I will use the following notation for a command description: command names are bold, strings are denoted by commas, variable names are italic, numbers are typewriter. Optional arguments are placed in square brackets and default values for them are shown. Detailed description of color, line styles, color schemes, font types, TeX-like symbols and formulas can be found in corresponding section.

@menu
* Graphics setup (MGL)::        
* Axis settings (MGL)::         
* Transformation matrix (MGL)::  
* Export to file (MGL)::        
* Primitives drawing (MGL)::    
* Text printing (MGL)::         
* Axis and Colorbar (MGL)::     
* Legend (MGL)::                
* 1D plotting (MGL)::           
* 2D plotting (MGL)::           
* 3D plotting (MGL)::           
* Dual plotting (MGL)::         
* Vector fields (MGL)::         
* Other plotting (MGL)::        
* Nonlinear fitting (MGL)::     
* Data create (MGL)::           
* Data filling (MGL)::          
* Rearrange data (MGL)::        
* File I/O (MGL)::              
* Make another data (MGL)::     
* Commands on direction (MGL)::  
* Operators (MGL)::             
* Program flow (MGL)::          
* Command options (MGL)::       
* Suffixes::                    
@end menu


@c ##################################################################
@node Graphics setup (MGL), Transformation matrix (MGL), , MGL interface
@subsection Graphics setup (MGL)

Coomands in this group influences on overall graphics appearance. So all of them should be placed @emph{before} any actual plotting commands. 

@menu
* Transparency (MGL)::          
* Lighting (MGL)::              
* Fog (MGL)::                   
* Default sizes (MGL)::         
* Zooming (MGL)::               
* Cutting (MGL)::               
* Other settings (MGL)::        
@end menu

@c ==================================================================
@node Transparency (MGL), Lighting (MGL), , Graphics setup (MGL)
@subsubsection Transparency (MGL)
@cindex alpha
@cindex alphadef
@cindex transparent
@cindex transptype

There are several commands for setup transparency. The general command is @code{alpha} which switch on/off the transparency for overall plot. It influence only for graphics which created after @code{alpha} call (with one exeption, mglGraphGL). Command @code{alphadef} specify the default value of alpha-channel. You may switch off transparency of selected plot by command @code{transparent}. Finally, command @code{transptype} set the kind of transparency. @sref{Transparent surface sample}

@deffn {MGL command} alpha @code{[val=on]}
Sets the transparency on/off. It is recommended to call this command before any plotting command. Default value is @code{off}. Use @code{transparent off} in particular plot to disable its transparency.
@end deffn
@deffn {MGL command} alphadef @code{val}
Default value of alpha channel (transparency) for all plotting commands.
@end deffn
@deffn {MGL command} transparent @code{val}
Temporary switches transparency on/off for the plot.
@end deffn
@deffn {MGL command} transptype @code{val}
This command set the transparency type. Normal transparency (@samp{0}) -- below things is less visible than upper ones. It does not look well in OpenGL mode (mglGraphGL) for several surfaces. Glass-like transparency (@samp{1}) -- below and upper things are commutable and just decrease intensity of light by RGB channel. Lamp-like transparency (@samp{2}) -- below and upper things are commutable and are the source of some additional light. I recommend to set @code{alphadef 0.3} or less for lamp-like transparency.
@end deffn

@c ==================================================================
@node Lighting (MGL), Fog (MGL), Transparency (MGL), Graphics setup (MGL)
@subsubsection Lighting (MGL)
@cindex light
@cindex ambient

There are several commands for setup lighting. The general command is @code{mgl_set_light()} which switch on/off the lighting for overall plot. It influence only for graphics which created after @code{mgl_set_light()} call (with one exeption, mglGraphGL). Generally MathGL support up to 10 independend light sources. But in OpenGL mode only 8 of light sources is used due to OpenGL limitations. The position, color, brightness of each light source can be set separately. By default only one light source is active. It is source number @code{0} with white color, located at top of the plot.

@deffn {MGL command} light @code{[val=on]}
Sets the using of light on/off for overall plot. It is recommended to call this command before any plotting command. Default value is lightning off.
@end deffn
@deffn {MGL command} light @code{num val}
Switch on/off @var{num}-th light source separately.
@end deffn

@deffn {MGL command} light @code{num xpos ypos zpos} ['col'='w' @code{br=0.5}]
The command adds a light source with identification @var{num} at position @{@var{xpos}, @var{ypos}, @var{zpos}@}. The color of light is @var{col} (white by default). The brightness of light is @var{br} which must be in range [0,1].
@end deffn

@deffn {MGL command} ambient @code{val}
Sets the brightness of ambient light. The value should be in range [0,1]. Initial value is 0.5. 
@end deffn

@c ==================================================================
@node Fog (MGL), Default sizes (MGL), Lighting (MGL), Graphics setup (MGL)
@subsubsection Fog (MGL)
@cindex fog

@deffn {MGL command} fog @code{val [dz=0.25]}
Command imitate a fog in the plot. Fog start from relative distance @var{dz} from view point and its density growths exponentially in depth. So that the fog influence is determined by law ~ 1-exp(-@emph{val*z}). Here @emph{z} is normalized to 1 depth of the plot. If value @var{val}=@code{0} then the fog is absent. @sref{Surface in fog sample}
@end deffn

@c ==================================================================
@node Default sizes (MGL), Zooming (MGL), Fog (MGL), Graphics setup (MGL)
@subsubsection Default sizes (MGL)
@cindex marksize
@cindex arrowsize
@cindex linewidth

These commands control the default (initial) values for most graphics parameters including sizes of markers, arrows, linewidth and so on. As any other settings these ones will influence only on plots created after the settings change.

@deffn {MGL command} marksize @code{val}
The size of marks. Default value is @code{1}.
@end deffn

@deffn {MGL command} arrowsize @code{val}
The size of arrows for lines and curves. Default value is @code{1}.
@end deffn

@deffn {MGL command} linewidth @code{val}
The variable define the base width for all lines. The value <1 is ignored. Increase of this variables is actual for large bitmap pictures. Default value is @code{1}.
@end deffn

@c ==================================================================
@node Zooming (MGL), Cutting (MGL), Default sizes (MGL), Graphics setup (MGL)
@subsubsection Zooming (MGL)
@cindex plotfactor
@cindex zoom

These commands control the overall zooming of the picture or the sub-picture. Normally you can use these variables and commands for removing ``white'' spaces around a plot.

@deffn {MGL command} plotfactor @code{val}
The factor of plot size. It is not recommended to set it lower then 1.6. This is some anlogue of command @code{zoom} but applied not to overall image but for each @code{inplot}. Use negative value to enable automatic @code{plotfactor} selection.
@end deffn

@deffn {MGL command} zoom @code{x1 y1 x2 y2}
The command changes the scale of graphics that correspond to zoom in/out of the picture. After command call the current plot will be cleared and further the picture will contain plotting from its part [x1,x2]*[y1,y2]. Here picture coordinates @var{x1}, @var{x2}, @var{y1}, @var{y2} changes from 0 to 1. Use @code{zoom 0 0 1 1} to return default view.
@end deffn

@c ==================================================================
@node Cutting (MGL), Other settings (MGL), Zooming (MGL), Graphics setup (MGL)
@subsubsection Cutting (MGL)
@cindex cut

These commands set the condition when the points are excluded (cutted) from the drawing.

@deffn {MGL command} cut @code{val}
Determines how points outside bounding box are drawn. If it is @code{true} then points are excluded from plot (it is default) otherwise the points are projected to edges of bounding box.
@end deffn

@deffn {MGL command} cut @code{x1 y1 z1 x2 y2 z2}
Lower and upper edge of the box in which never points are drawn. If both edges are the same (the variables are equal) then the cutting box is empty. @sref{CutMinMax sample}
@end deffn

@deffn {MGL command} cut 'cond'
Command set the cutting off condition by formula @var{cond}. This condition determine will point be plotted or not. If value of formula is nonzero then point is omitted, otherwise it plotted. Set argument as @code{''} to disable cutting off condition. @sref{CutOff sample}
@end deffn

@c ==================================================================
@node Other settings (MGL), , Cutting (MGL), Graphics setup (MGL)
@subsubsection Other settings (MGL)
@cindex font
@cindex rotatetext
@cindex palette
@cindex meshnum
@cindex axialdir

@deffn {MGL command} font 'fnt' [@code{val=6}]
Font style for text and labels (see text). Initial style is 'fnt'='rC' â€“ Roman font with centerin. Parameter @code{val} sets the size of font for tick and axis labels. Default font size of axis labels is 1.4 times large than for tick labels. For more detail, @pxref{Font style}.
@end deffn

@deffn {MGL command} rotatetext @code{val}
Set to use or not text rotation along axis. Initial value is @code{on}.
@end deffn

@deffn {MGL command} palette 'colors'
Set the palette as selected colors. Deafult value is @code{'Hbgrcmyhlnqeup'}. The palette is used mostly in 1D plots for curves which styles are not specified.
@end deffn

@deffn {MGL command} meshnum @code{num}
Sets approximate number of lines in @code{mesh, fall, grid} and also the number of hachures in @code{vect, vectc, dew} and the number of cells in @code{cloud}. By default (=0) it draws all lines/hachures/cells.
@end deffn

@deffn {MGL command} axialdir 'dir'
Set direction around which curve rotated in @code{axial, torus}. Default value is 'z'.
@end deffn

@c ==================================================================
@node Axis settings (MGL), Transformation matrix (MGL), Graphics setup (MGL), MGL interface
@subsection Axis settings (MGL)
@cindex axis
@cindex caxis
@cindex xrange
@cindex yrange
@cindex zrange
@cindex xtick
@cindex ytick
@cindex ztick
@cindex ctick
@cindex crange
@cindex ctick
@cindex origin

These large set of commands control how the axis and ticks will be drawn. Note that there is 3-step transformation of data coordinates are performed. Firstly, coordinates are projected and cutting is applied (@pxref{Cutting (MGL)}), after it transformation formulas are applied, and finally the data was normalized in bounding box.

@deffn {MGL command} axis @code{x1 y1 x2 y2}
@deffnx {MGL command} axis @code{x1 y1 z1 x2 y2 z2}
Sets the ranges of coordinates changing. Also it sets the range for coloring (analogous to @code{caxis z1 z2}). Initial ranges are [-1, 1].
@end deffn

@deffn {MGL command} axis 'fx' 'fy' 'fz'
Sets the transformation formulas for curvilinear coordinates. Each string should contain mathematical expression for real coordinate depending on internal coordinates x, y, z. For example, the cylindrical coordinates are introduced as @code{axis 'x*cos(y)' 'x*sin(y)' 'z'}. For removing of formulas the corresponding parameter should be @code{''}. The using of transformation formulas will slightly slowing the program, i.e. @code{axis '' '' ''} is faster than @code{axis 'x' 'y' 'z'}. Initially all formulas are absent (Cartesian coordinates are used). For more details about functions and formulas, @pxref{mglFormula class}.
@end deffn

@deffn {MGL command} caxis @code{z1 z2}
Sets the range for surface coloring. Initial range is [-1, 1].
@end deffn

@deffn {MGL command} crange dat [@code{add=off}]
Sets the range for surface coloring as minimal and maximal values of data @var{dat}. Parameter @code{add=on} shows that the new range will be joined to existed one (nut will not replace it).
@end deffn
@deffn {MGL command} crange @code{c1 c2}
Sets the range for surface coloring. See also caxis.
@end deffn

@deffn {MGL command} origin @code{x0 y0 [z0=nan]}
Center of axis cross section. If one of values is @code{nan} then MathGL library try to select optimal axis position.
@end deffn

@deffn {MGL command} ternary @code{val}
The command sets to draws Ternary plot. This special plot is for 3 dependent coordinates (components) @var{a}, @var{b}, @var{c} so that @var{a}+@var{b}+@var{c}=1. MathGL uses only 2 independent coordinates @var{a}=x and @var{b}=y since it is enough to plot everything. At this third coordinate z act as another parameter to produce contour lines, surfaces and so on. @sref{Ternary plot sample}
@end deffn

@deffn {MGL command} xrange dat [@code{add=off}]
@deffnx {MGL command} yrange dat [@code{add=off}]
@deffnx {MGL command} zrange dat [@code{add=off}]
@deffnx {MGL command} crange dat [@code{add=off}]
Sets the range for x-,y-,z- coordinate or coloring as minimal and maximal values of data @var{dat}. Parameter @code{add=on} shows that the new range will be joined to existed one (nut will not replace it).
@end deffn

@deffn {MGL command} xrange @code{x1 x2}
@deffnx {MGL command} yrange @code{x1 x2}
@deffnx {MGL command} zrange @code{x1 x2}
@deffnx {MGL command} crange @code{x1 x2}
Sets the range for x-,y-,z- coordinate or coloring. See also axis.
@end deffn

@deffn {MGL command} xtick @code{val [sub=0 org=nan]}
@deffnx {MGL command} ytick @code{val [sub=0 org=nan]}
@deffnx {MGL command} ztick @code{val [sub=0 org=nan]}
Step for x-, y-, z-axis ticks (if @var{cal}>0) or it's number (if @var{val}<0) in x-direction. Zero value @var{val}=0 sets logarithmic ticks. Parameter @var{sub} sets the number of subticks. Parameter @var{org} set the starting points for ticks. If not @code{org=nan} then the value from @code{origin} is used.
@end deffn

@deffn {MGL command} xtick 'templ'
@deffnx {MGL command} ytick 'templ'
@deffnx {MGL command} ztick 'templ'
@deffnx {MGL command} ctick 'templ'
The template for x-, y-, z-axis ticks or colorbar ticks. It may contain TeX symbols also. If @var{templ}=@code{''} then default template is used (in simplest case it is @samp{%.2g}) with automatic detaching of common multiplier or common component.
@end deffn

@c ##################################################################
@node Transformation matrix (MGL), Export to file (MGL), Axis settings (MGL), MGL interface
@subsection Transformation matrix (MGL)
@cindex aspect
@cindex rotate
@cindex subplot
@cindex inplot
@cindex identity
@cindex perspective

These commands control how and where further plotting will be placed. There is a curtain order of calling of these commands for the better plot view. First one should be @code{subplot} or @code{inplot} for specifying the place. After it a @code{rotate} and @code{aspect}. And finally any other plotting commands may be called.

@deffn {MGL command} subplot @code{nx ny m [dx=0 dy=0]}
Puts further plotting in a @var{m}-th cell of @var{nx}*@var{ny} grid of the whole frame area. This command set off any aspects or rotations. So it should be used first for creating the subplot. From the aesthetical point of view it is not recommended to use this command with different matrices in the same frame. The position of the cell can be shifted from its default position by relative size @var{dx}, @var{dy}.
@end deffn

@deffn {MGL command} inplot @code{x1 x2 y1 y2}
Puts further plotting in some region of the whole frame surface. This command allows one to create a plot in arbitrary place of the screen. The position is defined by rectangular coordinates [@var{x1}, @var{x2}]*[@var{y1}, @var{y2}]. The coordinates @var{x1}, @var{x2}, @var{y1}, @var{y2} are normalized to interval [0, 1]. This command set off any aspects or rotations. So it should be used first for creating subplot.
@end deffn

@deffn {MGL command} rotate @code{tetz tetx [tety=0]}
Rotates a further plotting relative to each axis (x, z, y) consecutively on angles @var{tetx}, @var{tetz}, @var{tety}.
@end deffn

@deffn {MGL command} rotate @code{tet x y z}
Rotates a further plotting around vector @{x,y,z@} on angle @var{tet}.
@end deffn

@deffn {MGL command} aspect @code{ax ay [az=1]}
Defines aspect ratio for the plot. The viewable axes will be related one to another as the ratio @var{ax:ay:az}. For the best effect it should be used after @code{rotate} command.
@end deffn

@deffn {MGL command} perspective @code{val}
Add (switch on) the perspective to plot. The parameter @math{val ~ 1/z_@{eff@} \in [0,1)}. By default (@code{val=0}) the perspective is off.
@end deffn

@c ##################################################################
@node Export to file (MGL), Primitives drawing (MGL), Transformation matrix (MGL), MGL interface
@subsection Export to file (MGL)
@cindex write
@cindex setsize

@deffn {MGL command} write 'fname' [@code{solid=off}]
Exports current picture to PNG file 'fname'. Solid (usually white) background will be used if @code{solid=on}.
@end deffn

@deffn {MGL command} setsize @code{w h}
Sets size of picture in pixels. This function call @strong{must be} placed before any plotting command because it completely remove picture content. In some program the call of this function is forbidden.
@end deffn


@c ##################################################################
@node Primitives drawing (MGL), Text printing (MGL), Export to file (MGL), MGL interface
@subsection Primitives drawing
@cindex ball
@cindex clf
@cindex line
@cindex curve
@cindex facex
@cindex facey
@cindex facez
@cindex cone
@cindex drop
@cindex sphere

These commands draw some simple objects like line, point, sphere, drop, cone and so on.

@deffn {MGL command} clf
Clear the picture by removes all drawing from it. Does not change transformation matrix. 
@end deffn

@deffn {MGL command} ball @code{x y} ['col'='r']
@deffnx {MGL command} ball @code{x y z} ['col'='r']
Draws a point (ball) at position @{@var{x}, @var{y}, @var{z}@} with color defined by string @var{col}.
@end deffn

@deffn {MGL command} line @code{x1 y1 x2 y2} ['stl'='']
@deffnx {MGL command} line @code{x1 y1 z1 x2 y2 z2} ['stl'='']
Draws a geodesic line (strightline in Cartesian coordinates) from point @{@var{x1},@var{y1},@var{z1}@} to @{@var{x2},@var{y2},@var{z2}@} using line style @var{stl}.
@end deffn

@deffn {MGL command} curve @code{x1 y1 dx1 dy1 x2 y2 dx2 dy2} ['stl'='']
@deffnx {MGL command} curve @code{x1 y1 z1 dx1 dy1 dz1 x2 y2 z2 dx2 dy2 dz2} ['stl'='']
Draws Bezier-like curve from point @{@var{x1},@var{y1},@var{z1}@} to @{@var{x2},@var{y2},@var{z2}@} using line style @var{stl}. At this tangent is codirected with @{@var{dx1},@var{dy1},@var{dz1}@}, @{@var{dx2},@var{dy2},@var{dz2}@} and proportional to its amplitude.
@end deffn

@deffn {MGL command} facex @code{x0 y0 z0 wy wz} ['stl'='' @code{d1=0 d2=0}]
@deffnx {MGL command} facey @code{x0 y0 z0 wx wz} ['stl'='' @code{d1=0 d2=0}]
@deffnx {MGL command} facez @code{x0 y0 z0 wx wy} ['stl'='' @code{d1=0 d2=0}]
Draws the solid rectangle (face) perpendicular to [x,y,z]-axis correspondingly at position @{@var{x0}, @var{y0}, @var{z0}@} with color @var{stl} and with widths @var{wx}, @var{wy}, @var{wz} along corresponding directions. At this colors can be the same for all vertexes or different if all 4 colors are specified for each vertex. Parameters @var{d1}!=0, @var{d2}!=0 set additional shift of the last vertex (i.e. to draw quadrangle).
@end deffn

@deffn {MGL command} sphere @code{x0 y0 r} ['col'='r']
@deffnx {MGL command} sphere @code{x0 y0 z0 r} ['col'='r']
Draw the spehere with radius @var{r} and center at point @{@var{x0}, @var{y0}, @var{z0}@} and color @var{stl}.
@end deffn

@deffn {MGL command} drop @code{x0 y0 dx dy r} ['col'='b' @code{sh=1 asp=1}]
@deffnx {MGL command} drop @code{x0 y0 z0 dx dy dz r} ['col'='b' @code{sh=1 asp=1}]
Draw the drop with radius @var{r} at point @{@var{x0},@var{y0},@var{z0}@} elongated in direction @{@var{dx},@var{dy},@var{dz}@} and with color @var{col}. Parameter @var{sh} set the degree of drop oblongness: @samp{0} is sphere, @samp{1} is maximally oblongness drop. Parameter @var{asp} set relative width of the drop (this is analogue of ``ellipticity'' for the sphere). @sref{Drops sample}
@end deffn

@deffn {MGL command} cone @code{x1 y1 z1 x2 y2 z2 r1} [@code{r2=-1} 'st'='' @code{edge=off}]
Draw tube (or truncated cone if @var{edge}=@code{off}) between points @{@var{x1},@var{y1},@var{z1}@}, @{@var{x2},@var{y2},@var{z2}@} with radiuses at the edges @var{r1}, @var{r2}. If @var{r2}<0 then it is suppsosed that @var{r2}=@var{r1}. The cone color is defined by string @var{stl}.
@end deffn

@deffn {MGL command} rect @code{x1 y1 x2 y2} ['st'='']
@deffnx {MGL command} rect @code{x1 y1 z1 x2 y2 z2} ['st'='']
Draw rectangle from point @{@var{x1},@var{y1},@var{z1}@} to point @{@var{x2},@var{y2},@var{z2}@} using colors @var{stl}. If @var{stl} have 4 or more colors then it defines colors for each rectangle vertex (useful for making gradients, like @samp{wwrr}) else first color is used for whole rectangle.
@end deffn

@c ##################################################################
@node Text printing (MGL), Axis and Colorbar (MGL), Primitives drawing (MGL), MGL interface
@subsection Text printing (MGL)
@cindex fgets
@cindex text
@cindex title

These commands draw the text. There are commands for drawing text in arbitrary place, in arbitrary direction and along arbitrary curve. It is possible to use arbitrary fontfaces and parse many TeX commands. The Unicode text is supported. So sometimes you need to specify locale. The @code{size} argument control the size of text: if positive it give the value, if negative it give the value relative to defined by @code{font} command. @xref{Font style}.

@deffn {MGL command} text @code{x y} 'text' ['fnt'='' @code{size=-1.4}]
@deffnx {MGL command} text @code{x y z} 'text' ['fnt'='' @code{size=-1.4}]
Draws unrotated text string @var{text} at position @{@var{x},@var{y},@var{z}@} with specified style @var{fnt} and @var{size}. By default parameters from @code{font} command are used.
@end deffn

@deffn {MGL command} text @code{x y dx dy} 'text' ['fnt'='' @code{size=-1.4}]
@deffnx {MGL command} text @code{x y z dx dy dz} 'text' ['fnt'='' @code{size=-1.4}]
The command plots the string @var{text} at position @{@var{x},@var{y},@var{z}@} along direction @{@var{dx},@var{dy},@var{dz}@} with specified style @var{fnt} and @var{size}. By default parameters from @code{font} command are used.
@end deffn

@deffn {MGL command} title 'text' ['fnt'='' @code{size=-2}]
Print string @var{text} as title of the picture (at the top of the picture). Can be used at any place (even inside @code{subplot}).
@end deffn

@deffn {MGL command} fgets @code{x y} 'fname' [@code{n=0} 'fnt'='' @code{size=-1.4}]
@deffnx {MGL command} fgets @code{x y z} 'fname' [@code{n=0} 'fnt'='' @code{size=-1.4}]
Draws unrotated @var{n}-th line of file @var{fname} at position @{@var{x},@var{y},@var{z}@} with specified style @var{fnt} and @var{size}. By default parameters from @code{font} command are used.
@end deffn


@deffn {MGL command} text xdat 'text' ['fnt'='' @code{size=-1 zval=nan}]
@deffnx {MGL command} text xdat ydat 'text' ['fnt'='' @code{size=-1 zval=nan}]
@deffnx {MGL command} text xdat ydat zdat 'text' ['fnt'='' @code{size=-1}]
The command draws @var{text} along the curve between points @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@} by font style @var{fnt} and with size @var{size}. The string @var{fnt} may contain symbols @samp{t} for printing the text under the curve (default), or @samp{T} for printing the text above the curve. The sizes of 1st dimension must be equal for all arrays @var{xdat.nx=ydat.nx=zdat.nx}. If array @var{xdat} is not specified then its an automatic array is used with values equidistantly distributed along x. If array @var{zdat} is not specified then @var{z}[i] = @var{zval} is used. @sref{Text sample}
@end deffn

@c ##################################################################
@node Axis and Colorbar (MGL), Legend (MGL), Text printing (MGL), MGL interface
@subsection Axis and Colorbar (MGL)
@cindex axis
@cindex box
@cindex grid
@cindex colorbar
@cindex xlabel
@cindex ylabel
@cindex zlabel

These commands draw the ``things for measuring'', like axis with ticks, colorbar with ticks, grid along axis, bounding box and labels for axis. For more information @pxref{Axis settings (MGL)}.

@deffn {MGL command} axis ['dir'='xyz']
Draws axes with ticks (@pxref{Axis settings (MGL)}) in directions determined by string parameter @var{dir}.If string contain the symbol @samp{_} then tick labels are not printed. Font for ticks labels is determined by command @code{font}.
@end deffn

@deffn {MGL command} colorbar ['sch'='' @code{pos=0}]
Draws colorbar with color scheme @var{sch} (current scheme if @code{sch=''}) at edge of plot. Parameter @var{pos} specifies the position of colorbar: @samp{0} - at right (default), @samp{1} - at left, @samp{2} - at top, @samp{3} - at bottom. @sref{Dens sample}
@end deffn

@deffn {MGL command} grid ['dir'='xyz' 'pen'='B']
Draws grid lines perpendicular to direction determined by string parameter @var{dir}. The step of grid lines is the same as tick step for an @code{axis}. The style of lines is determined by @var{pen} parameter.
@end deffn

@deffn {MGL command} box ['stl'='k']
Draws bounding box outside the plotting volume with line style 'stl'.
@end deffn

@deffn {MGL command} xlabel 'text' [@code{pos=1 shift=0}]
@deffnx {MGL command} ylabel 'text' [@code{pos=1 shift=0}]
@deffnx {MGL command} zlabel 'text' [@code{pos=1 shift=0}]
Prints the label @var{text} for x-,y-,z-axis. The position of label is determined by @var{pos} parameter. If @var{pos}=0 then label is printed at the center of axis. If @var{pos}>0 then label is printed at the maximum of axis (default). If @var{pos}<0 then label is printed at the minimum of axis. The font size is 1.4 times larger than the one for ticks @code{font}. Parameter @code{shift} specify additional shifting of the label. @xref{Text printing (MGL)}.
@end deffn

@c ##################################################################
@node Legend (MGL), 1D plotting (MGL), Axis and Colorbar (MGL), MGL interface
@subsection Legend (MGL)
@cindex legend
@cindex addlegend
@cindex clearlegend

These commands draw legend to the graph (useful for @ref{1D plotting (MGL)}). Legend entry is a pair of strings: one for style of the line, another one with description text (with included LaTeX parsing). The array of string are accumulated first to the internal arrays (by command AddLegend()) and are plotted later. The position of the legend can be selected automatic or manually. Parameters @var{fnt} and @var{size} specify the font style and size. Parameter @var{llen} set the relative width of the line sample and the text indent (default value is 0.1). If line style string for entry is empty then the corresponding text is printed without indent. @sref{Legend sample}

@deffn {MGL command} legend [@code{pos=3} 'fnt'='rL' @code{size=-1 llen=0.1}]
Draws legend of accumulated legend entries by font @var{fnt} with specified @var{size}. Parameter @var{pos} sets the position of the legend: @samp{0} is bottom left corner, @samp{1} is bottom right corner, @samp{2} is top left corner, @samp{3} is top right corner (is default).
@end deffn

@deffn {MGL command} legend @code{x y} ['fnt'='rL' @code{size=-1 llen=0.1}]
Draws legend of accumulated legend entries by font @var{fnt} with @var{size}. Position of legend is determined by parameter @var{x}, @var{y} which supposed to be normalized to interval [0,1].
@end deffn

@deffn {MGL command} addlegend 'text' 'stl'
Adds string @var{text} to internal legend accumulator. The style of described line and mark is specified in string @var{stl} (@pxref{Line styles}). Maximal number of entries is 100.
@end deffn

@deffn {MGL command} clearlegend
Clears saved legend strings.
@end deffn

@deffn {MGL command} legendbox @code{val}
Switches on/off the drawing of a box near legend. By default, the box is drawn.
@end deffn



@c ##################################################################
@node 1D plotting (MGL), 2D plotting (MGL), Legend (MGL), MGL interface
@subsection 1D plotting (MGL)
@cindex plot
@cindex area
@cindex bars
@cindex barh
@cindex stem
@cindex step
@cindex torus
@cindex chart
@cindex mark
@cindex textmark
@cindex error
@cindex tube
@cindex region

These commands perform plotting of 1D data. 1D means that data depended from only 1 parameter like parametric curve @{x(i),y(i),z(i)@}, i=1...n. There are 5 generally different types of data representations: simple line plot (Plot), line plot with filling under it (Area), stairs plot (Step), bar plot (Bars, Barh) and vertical lines (Stem). Each type of plotting has similar interface. There are 3D version and two 2D versions. One of last requires single array. The parameters of line and marks are specified by the string argument. If the string parameter is NULL then solid line with color from palette Pal is used (@pxref{Palette and colors}). Also there are some special 1d plots having slightly different interface: surface of curve rotation (Torus), chart (Chart) and error boxes (Error), marks with variable size (Mark), tubes (Tube) and so on. @xref{Line styles}.

The plots are drawn for each row if one of the data is the matrix. By any case the sizes of 1st dimension @strong{must be equal} for all arrays @var{x.nx=y.nx=z.nx}. String @var{pen} specifies the color and style of line and marks (@pxref{Line styles}). By default (@code{pen=NULL}) solid line with color from palette is used (@pxref{Palette and colors}).

@deffn {MGL command} plot ydat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} plot xdat ydat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} plot xdat ydat zdat ['stl'='']
Draws continuous lines between points @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@}. If array @var{xdat} is not specified then its an automatic array is used with values equidistantly distributed along x. If array @var{zdat} is not specified then @var{zdat}[i] = @var{zval} is used (the default is at the bottom of the bounding box). See also @code{area, step, stem, tube, mark, error, belt}. @sref{Plot sample}
@end deffn

@deffn {MGL command} area ydat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} area xdat ydat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} area xdat ydat zdat ['stl'='']
Draws continuous lines between points @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@} and fills it down to axis (to axis plane in 3D). If array @var{xdat} is not specified then its an automatic array is used with values equidistantly distributed along x. If array @var{zdat} is not specified then @var{zdat}[i] = @var{zval} is used (the default is at the bottom of the bounding box). See also @code{plot, bars, stem, region}. @sref{Area sample}
@end deffn

@deffn {MGL command} region fdat gdat ['stl'='' @code{inside=off}]
@deffnx {MGL command} region xdat fdat gdat ['stl'='' @code{inside=off}]
Fills area between curves @{@var{xdat}[i], @var{fdat}[i]@} and @{@var{xdat}[i], @var{gdat}[i]@}. If array @var{xdat} is not specified then its an automatic array is used with values equidistantly distributed along x.  Parameter  @code{inside=off} set to fill are with y1<y<y2 else the area with y2<y<y1 will be also filled.
@c If array @var{zdat} is not specified then @var{zdat}[i] = @var{zval} is used (the default is at the bottom of the bounding box). 
See also @code{area, bars, stem}. @sref{Region sample}
@end deffn

@deffn {MGL command} bars ydat ['stl'='' @code{zval=nan above=off}]
@deffnx {MGL command} bars xdat ydat ['stl'='' @code{zval=nan above=off}]
@deffnx {MGL command} bars xdat ydat zdat ['stl'='' @code{above=off}]
Draws vertical bars from points @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@} to axis (to axis plane in 3D). If array @var{xdat} is not specified then its an automatic array is used with values equidistantly distributed along x. If array @var{zdat} is not specified then @var{zdat}[i] = @var{zval} is used (the default is at the bottom of the bounding box). Bars are drawn side-by-side (if @code{above = off}) or one above another (if @code{above = on}). Marks at data points are not drawn. See also @code{area, barh, stem, chart}. @sref{Bars sample}
@end deffn

@deffn {MGL command} barh vdat ['stl'='' @code{zval=nan above=off}]
@deffnx {MGL command} bars ydat vdat ['stl'='' @code{zval=nan above=off}]
Draws horizontal bars from points @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@} to y-axis. If array @var{ydat} is not specified then its an automatic array is used with values equidistantly distributed along y. Bars are drawn side-by-side (if @code{above = off}) or one above another (if @code{above = on}). Marks at data points are not drawn.
@c If array @var{zdat} is not specified then @var{zdat}[i] = @var{zval} is used (the default is at the bottom of the bounding box). 
See also @code{bars}. @sref{Barh sample}
@end deffn

@deffn {MGL command} stem ydat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} stem xdat ydat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} stem xdat ydat zdat ['stl'='']
Draws vertical lines from points @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@} to axis (to axis plane in 3D). If array @var{xdat} is not specified then its an automatic array is used with values equidistantly distributed along x. If array @var{zdat} is not specified then @var{zdat}[i] = @var{zval} is used (the default is at the bottom of the bounding box). See also @code{area, bars, plot, mark}. @sref{Stem sample}
@end deffn

@deffn {MGL command} step ydat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} step xdat ydat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} step xdat ydat zdat ['stl'='']
Draws continuous stairs for points @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@}. If array @var{xdat} is not specified then its an automatic array is used with values equidistantly distributed along x. If array @var{zdat} is not specified then @var{zdat}[i] = @var{zval} is used (the default is at the bottom of the bounding box). See also @code{plot, stem, tile, boxs}. @sref{Step sample}
@end deffn

@deffn {MGL command} torus zdat ['stl'='']
@deffnx {MGL command} torus rdat zdat ['stl'='']
Draws surface which is result of curve @{@var{rdat}[i], @var{zdat}[i], @var{zdat}[i]@} rotation around @code{axialdir} axis. If array @var{rdat} is not specified then its an automatic array is used with values equidistantly distributed along x. See also @code{plot, axial}. @sref{Torus sample}
@end deffn

@deffn {MGL command} chart adat ['col'='']
The command draws colored stripes (boxes) for data in array @var{adat}. The number of stripes is equal to the number of rows in @var{adat} (equal to @var{a.ny}). The color of each next stripe is ciclically changed from colors specified in string @var{col} or in palette. Spaces in colors denote transparent ``color'', i.e. if @var{col} contain space(s) then corresponding stripe(s) are not drawn. The stripe width is proportional to value of element in @var{a}. Chart is plotted only for data with non-negative elements. If string @var{col} have symbol @samp{#} then black border lines are drawn. The most nice form the chart have in 3d (after rotation of coordiantes) or in cilindrical coordinates (becomes so called Pie chart). @sref{Chart sample}
@end deffn

@deffn {MGL command} mark ydat rdat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} mark xdat ydat rdat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} mark xdat ydat zdat rdat ['stl'='']
Draws  marks with size @var{rdat}[i]*@code{marksize} at points @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@}. If array @var{xdat} is not specified then its an automatic array is used with values equidistantly distributed along x. If array @var{zdat} is not specified then @var{zdat}[i] = @var{zval} is used (the default is at the bottom of the bounding box). See also @code{plot, textmark, stem, error}. @sref{Mark sample}
@end deffn

@deffn {MGL command} textmark ydat 'txt' ['stl'='' @code{zval=nan}]
@deffnx {MGL command} textmark ydat rdat 'txt' ['stl'='' @code{zval=nan}]
@deffnx {MGL command} textmark xdat ydat rdat 'txt' ['stl'='' @code{zval=nan}]
@deffnx {MGL command} textmark xdat ydat zdat rdat 'txt' ['stl'='']
Draws string @var{txt} as marks with size @var{rdat}[i]*@code{marksize} at points @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@}. If array @var{xdat} is not specified then its an automatic array is used with values equidistantly distributed along x. If array @var{zdat} is not specified then @var{zdat}[i] = @var{zval} is used (the default is at the bottom of the bounding box). If array @var{rdat} is not specified then @var{rdat}[i] = 1. See also @code{plot, mark, stem}. @sref{TextMark sample}
@end deffn

@deffn {MGL command} error ydat yerr ['stl'='' @code{zval=nan}]
@deffnx {MGL command} error xdat ydat yerr ['stl'='' @code{zval=nan}]
@deffnx {MGL command} error xdat ydat xerr yerr ['stl'='' @code{zval=nan}]
Draws error boxes @{@var{xerr}[i], @var{yerr}[i]@} at points @{@var{xdat}[i], @var{ydat}[i], @var{zval}@}. If array @var{xdat} is not specified then its an automatic array is used with values equidistantly distributed along x. See also @code{plot}. @sref{TextMark sample}
@end deffn

@deffn {MGL command} tube ydat rdat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} tube ydat @code{rval} ['stl'='' @code{zval=nan}]
@deffnx {MGL command} tube xdat ydat rdat ['stl'='' @code{zval=nan}]
@deffnx {MGL command} tube xdat ydat @code{rval} ['stl'='' @code{zval=nan}]
@deffnx {MGL command} tube xdat ydat zdat rdat ['stl'='']
@deffnx {MGL command} tube xdat ydat zdat @code{rval} ['stl'='']
Draws tube with variable radius @var{rdat}[i] (or @var{rval}) at points @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@}. If array @var{xdat} is not specified then its an automatic array is used with values equidistantly distributed along x. If array @var{zdat} is not specified then @var{zdat}[i] = @var{zval} is used (the default is at the bottom of the bounding box). See also @code{plot}. @sref{TextMark sample}
@end deffn


@c ##################################################################
@node 2D plotting (MGL), 3D plotting (MGL), 1D plotting (MGL), MGL interface
@subsection 2D plotting (MGL)
@cindex mesh
@cindex fall
@cindex belt
@cindex surf
@cindex boxs
@cindex tile
@cindex dens
@cindex cont
@cindex contf
@cindex axial
@cindex grid

These commands perform plotting of 2D data. 2D means that data depend from 2 independent parameters like matrix @math{f(x_i,y_j), i=1...n, j=1...m}. There are 6 generally different types of data representations: simple mesh lines plot (Mesh), surface plot (Surf), surface plot by boxes (Boxs), surface plot by tiles (Tile), waterfall-like plot (Fall), belt plot (Belt), density plot (Dens), contour lines plot (Cont), solid contours plot (ContF) and its rotational figure (Axial). Cont, ContF and Axial commands have variants for automatic and manual selection of level values for contours. Also there are commands for plotting data grid lines according to the data format (Grid) for enhancing density or contour plots. Each type of plotting has similar interface. There are 2 kind of versions which handle the arrays of data and coordinates or only single data array. Parameters of color scheme are specified by the string argument.

String parameter @var{sch} sets the color scheme (@pxref{Color scheme}). Previous color scheme is used by default. The minor dimensions of arrays @var{xdat}, @var{ydat}, @var{zdat} should be equal @var{xdat.nx=zdat.nx && ydat.nx=zdat.ny} or @var{xdat.nx=ydat.nx=zdat.nx && xdat.ny=ydat.ny=zdat.ny}. Arrays @var{xdat} and @var{ydat} can be vectors (not matrices as @var{zdat}). If array @var{xdat}, @var{ydat} is not specified then its an automatic arrays are used with values equidistantly distributed along x, y. Graphics are plotted for each z-slice of the data.

@deffn {MGL command} mesh zdat ['sch'='']
@deffnx {MGL command} mesh xdat ydat zdat ['sch'='']
Draws mesh lines for surface specified parametrically @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@}. See also @code{surf, fall, meshnum, cont}. @sref{Mesh sample}
@end deffn

@deffn {MGL command} fall zdat ['sch'='']
@deffnx {MGL command} fall xdat ydat zdat ['sch'='']
Draws fall lines for surface specified parametrically @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@}. If @var{sch} contain @samp{x} then lines are drawn along x-direction else (by default) lines are drawn along y-direction. See also @code{belt, mesh, meshnum}. @sref{Fall sample}
@end deffn

@deffn {MGL command} belt zdat ['sch'='']
@deffnx {MGL command} belt xdat ydat zdat ['sch'='']
Draws belts for surface specified parametrically @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@}. If @var{sch} contain @samp{x} then belts are drawn along x-direction else (by default) lines are drawn along y-direction. See also @code{fall, surf, plot, meshnum}. @sref{Belt sample}
@end deffn

@deffn {MGL command} surf zdat ['sch'='']
@deffnx {MGL command} surf xdat ydat zdat ['sch'='']
Draws surface specified parametrically @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@}. See also @code{mesh, dens, belt, tile, boxs, surfc, surfa}. @sref{Surf sample}
@end deffn

@deffn {MGL command} boxs zdat ['sch'='']
@deffnx {MGL command} boxs xdat ydat zdat ['sch'='']
Draws vertical boxes for surface specified parametrically @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@}. See also @code{surf, dens, tile, step}. @sref{Boxs sample}
@end deffn

@deffn {MGL command} tile zdat ['sch'='']
@deffnx {MGL command} tile xdat ydat zdat ['sch'='']
Draws horizontal tiles for surface specified parametrically @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@}. See also @code{surf, dens, boxs, tile, step}. @sref{Tile sample}
@end deffn

@deffn {MGL command} dens zdat ['sch'='' @code{zval=nan}]
@deffnx {MGL command} dens xdat ydat zdat ['sch'='' @code{zval=nan}]
Draws density plot for surface specified parametrically @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@} at @var{z} = @var{zVal}. See also @code{surf, cont, contf, boxs, tile, dens[xyz]}. @sref{Dens sample}
@end deffn

@deffn {MGL command} cont vdat zdat ['sch'='' @code{zval=nan}]
@deffnx {MGL command} cont vdat xdat ydat zdat ['sch'='' @code{zval=nan}]
Draws contour lines for surface specified parametrically @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@} at @var{z} = @var{zVal} (or for @var{z}=@var{vdat}[k] if @code{zval=nan}). Contours are plotted for @var{zdat}[i,j]=@var{vdat}[k] for all k. If string @var{stl} contain 't' (or 'T') symbol then contour labels will be drawn below (or above) the contours. See also @code{dens, contf, axial, cont[xyz]}. @sref{Cont sample}
@end deffn

@deffn {MGL command} cont zdat ['sch'='' @code{num=7 zval=nan}]
@deffnx {MGL command} cont xdat ydat zdat ['sch'='' @code{num=7 zval=nan}]
The same as previous one with vector @var{vdat} of @var{num}-th elements equidistantly distributed in color range (see, @code{caxis}).
@end deffn

@deffn {MGL command} contf vdat zdat ['sch'='' @code{zval=nan}]
@deffnx {MGL command} contf vdat xdat ydat zdat ['sch'='' @code{zval=nan}]
Draws solid (or filled) contours for surface specified parametrically @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@} at @var{z} = @var{zVal} (or for @var{z}=@var{vdat}[k] if @code{zval=nan}). Contours are plotted for @var{zdat}[i,j]=@var{vdat}[k] for all k. See also @code{dens, cont, axial, contf[xyz]}. @sref{ContF sample}
@end deffn

@deffn {MGL command} contf zdat ['sch'='' @code{num=7 zval=nan}]
@deffnx {MGL command} contf xdat ydat zdat ['sch'='' @code{num=7 zval=nan}]
The same as previous one with vector @var{vdat} of @var{num}-th elements equidistantly distributed in color range (see, @code{caxis}).
@end deffn

@deffn {MGL command} axial vdat zdat ['sch'='']
@deffnx {MGL command} axial vdat xdat ydat zdat ['sch'='']
Draws surface which is result of contour plot rotation surface specified parametrically @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@}. Contours are plotted for @var{zdat}[i,j]=@var{vdat}[k] for all k. If string @var{sch} have symbol @samp{#} then wire plot is produced. If string @var{sch} contain symbols @samp{x}, @samp{y} or @samp{z} then rotation axis @code{axialdir} will be set to specified direction. If string @var{sch} have symbol @samp{#} then wire plot is produced. See also @code{cont, contf, torus, surf3}. @sref{Axial sample}
@end deffn

@deffn {MGL command} axial zdat ['sch'='' @code{num=3}]
@deffnx {MGL command} axial xdat ydat zdat ['sch'='' @code{num=3}]
The same as previous one with vector @var{vdat} of @var{num}-th elements equidistantly distributed in color range (see, @code{caxis}).
@end deffn

@deffn {MGL command} grid zdat ['sch'='' @code{zval=nan}]
@deffnx {MGL command} grid xdat ydat zdat ['sch'='' @code{zval=nan}]
Draws grid lines for density plot of surface specified parametrically @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@} at @var{z} = @var{zVal}. See also @code{dens, cont, contf}.
@end deffn


@c ##################################################################
@node 3D plotting (MGL), Dual plotting (MGL), 2D plotting (MGL), MGL interface
@subsection 3D plotting (MGL)
@cindex surf3
@cindex dens3
@cindex cont3
@cindex conta
@cindex densa
@cindex grid3
@cindex grida
@cindex cloud
@cindex contf3
@cindex contfa
@cindex beam

These commands perform plotting of 3D data. 3D means that data depend from 3 independent parameters like matrix @math{f(x_i,y_j,z_k), i=1...n, j=1...m, k=1...l}. There are 4 generally different types of data representations: isosurface or surface of constant value (Surf3), density plot at slices (Dens3), contour lines plot at slices (Cont3), solid contours plot at slices (ContF3) and cloud-like plot (Cloud). Surf3, Cont3 and ContF3 commands have variants for automatic and manual selection of level values for surfaces/contours. Also there are commands for plotting data grid lines according to the data format (Grid3) for enhancing density or contour plots. Each type of plotting has similar interface. There are 2 kind of versions which handle the arrays of data and coordinates or only single data array. Parameters of color scheme are specified by the string argument.

String paramter @var{sch} sets the color scheme (@pxref{Color scheme}). Previous color scheme is used by default. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). If array @var{xdat}, @var{ydat}, @var{zdat} is not specified then its an automatic arrays are used with values equidistantly distributed along x, y, z.


@deffn {MGL command} surf3 adat @code{val} ['sch'='']
@deffnx {MGL command} surf3 xdat ydat zdat adat @code{val} ['sch'='']
Draws isosurface plot for 3d array specified parametrically @var{adat}[i,j,k](@var{xdat}[i,j,k], @var{ydat}[i,j,k], @var{zdat}[i,j,k]) at @var{a}(x,y,z)=@var{val}. If string contain @samp{#} then wire plot is produced. See also @code{cloud, dens3, surf3c, surf3a, axial}. @sref{Surf3 sample}
@end deffn

@deffn {MGL command} surf3 adat ['sch'='' @code{num=5}]
@deffnx {MGL command} surf3 xdat ydat zdat adat ['sch'='' @code{num=5}]
Draws @var{num}-th uniformly distributed in color range (see @code{caxis}) isosurfaces for 3d data specified parametrically.
@end deffn

@deffn {MGL command} dens3 adat 'dir' [@code{sval=-1} 'sch'='']
@deffnx {MGL command} dens3 xdat ydat zdat adat 'dir' [@code{sval=-1} 'sch'='']
Draws density plot for 3d array specified parametrically @var{adat}[i,j,k](@var{xdat}[i,j,k], @var{ydat}[i,j,k], @var{zdat}[i,j,k]). Density is plotted at slice @var{sval} in @var{dir}=@{@samp{x}, @samp{y}, @samp{z}@} direction. If string @var{stl} have symbol @samp{#} then grid lines are drawn. See also @code{cont3, contf3, dens, grid3}. @sref{Dens3 sample}
@end deffn

@deffn {MGL command} densa adat ['sch'='']
@deffnx {MGL command} densa xdat ydat zdat adat ['sch'='']
Draws density plots at all central slices of the 3d data specified parametrically.
@end deffn

@deffn {MGL command} cont3 vdat adat 'dir' [@code{sval=-1} 'sch'='']
@deffnx {MGL command} cont3 vdat xdat ydat zdat adat 'dir' [@code{sval=-1} 'sch'='']
Draws contour plot for 3d array specified parametrically @var{adat}[i,j,k](@var{xdat}[i,j,k], @var{ydat}[i,j,k], @var{zdat}[i,j,k]). Contours are plotted for values specified in array @var{vdat} at slice @var{sval} in @var{dir}=@{@samp{x}, @samp{y}, @samp{z}@} direction. If string @var{stl} have symbol @samp{#} then grid lines are drawn. If string @var{stl} contain 't' (or 'T') symbol then contour labels will be drawn below (or above) the contours. See also @code{dens3, contf3, cont, grid3}. @sref{Cont3 sample}
@end deffn

@deffn {MGL command} cont3 adat 'dir' [@code{sval=-1} 'sch'='' @code{num=7}]
@deffnx {MGL command} cont3 xdat ydat zdat adat 'dir' [@code{sval=-1} 'sch'='' @code{num=7}]
The same as previous one with vector @var{vdat} of @var{num}-th elements equidistantly distributed in color range (see @code{caxis}).
@end deffn

@deffn {MGL command} conta adat ['sch'='' @code{num=7}]
@deffnx {MGL command} conta xdat ydat zdat adat ['sch'='' @code{num=7}]
Draws contour plots at all central slices of the 3d data specified parametrically.
@end deffn

@deffn {MGL command} contf3 vdat adat 'dir' [@code{sval=-1} 'sch'='']
@deffnx {MGL command} contf3 vdat xdat ydat zdat adat 'dir' [@code{sval=-1} 'sch'='']
Draws solid contour plot for 3d array specified parametrically @var{adat}[i,j,k](@var{xdat}[i,j,k], @var{ydat}[i,j,k], @var{zdat}[i,j,k]). Contours are plotted for values specified in array @var{vdat} at slice @var{sval} in @var{dir}=@{@samp{x}, @samp{y}, @samp{z}@} direction. If string @var{stl} have symbol @samp{#} then grid lines are drawn. See also @code{dens3, cont3, contf, grid3}. @sref{ContF3 sample}
@end deffn

@deffn {MGL command} contf3 adat 'dir' [@code{sval=-1} 'sch'='' @code{num=7}]
@deffnx {MGL command} contf3 xdat ydat zdat adat 'dir' [@code{sval=-1} 'sch'='' @code{num=7}]
The same as previous one with vector @var{vdat} of @var{num}-th elements equidistantly distributed in color range (see @code{caxis}).
@end deffn

@deffn {MGL command} contfa adat ['sch'='' @code{num=7}]
@deffnx {MGL command} contfa xdat ydat zdat adat ['sch'='' @code{num=7}]
Draws solid contour plots at all central slices of the 3d data specified parametrically.
@end deffn

@deffn {MGL command} grid3 adat 'dir' [@code{sval=-1} 'sch'='']
@deffnx {MGL command} grid3 xdat ydat zdat adat 'dir' [@code{sval=-1} 'sch'='']
Draws grid for 3d array specified parametrically @var{adat}[i,j,k](@var{xdat}[i,j,k], @var{ydat}[i,j,k], @var{zdat}[i,j,k]). Grid is plotted at slice @var{sval} in @var{dir}=@{@samp{x}, @samp{y}, @samp{z}@} direction. See also @code{cont3, contf3, dens, grid3}. @sref{Dens3 sample}
@end deffn

@deffn {MGL command} grida adat ['sch'='']
@deffnx {MGL command} grida xdat ydat zdat adat ['sch'='']
Draws grids at all central slices of the 3d data specified parametrically.
@end deffn

@deffn {MGL command} cloud adat ['sch'='']
@deffnx {MGL command} cloud xdat ydat zdat adat ['sch'='']
Draws cloud for 3d array specified parametrically @var{adat}[i,j,k](@var{xdat}[i,j,k], @var{ydat}[i,j,k], @var{zdat}[i,j,k]). This plot is a set of cubes with color and transparency proportional to value of @var{adat}. The resulting plot is like cloud -- low value is transparent but higher ones are not. The number of plotting cells depend on @code{meshnum}. Command @var{alpha} changes the overall transparency of plot. See also @code{surf3}. @sref{CloudQ sample}
@end deffn

@deffn {MGL command} beam tr g1 g2 adat @code{rval} ['sch'='' @code{flag=0 num=3}]
Draws  @var{num}-th uniformly distributed in color range (see @code{caxis}) isosurfaces for 3d array @var{adat}. This is special kind of plot for @var{adat} specified in accompanied coordinates along curve @var{tr} with orts @var{g1}, @var{g2} and with transverse scale @var{rval}. Variable @var{flag} is bitwise: @samp{0x1} - draw in accompanied (not laboratory) coordinates; @samp{0x2} - draw projection to @math{\rho-z} plane; @samp{0x4} - draw normalized in each slice field. The x-size of data arrays @var{tr}, @var{g1}, @var{g2} must be nx>2. The y-size of data arrays @var{tr}, @var{g1}, @var{g2} and z-size of the data array @var{a} must be equal. @xref{Surf3}.
@end deffn


@c ##################################################################
@node Dual plotting (MGL), Vector fields (MGL), 3D plotting (MGL), MGL interface
@subsection Dual plotting (MGL)
@cindex surfc
@cindex surf3c
@cindex surfa
@cindex surf3a
@cindex map
@cindex tile
@cindex stfa

These plotting commands draw @emph{two matrix} simultaneously. There are 5 generally different types of data representations: surface or isosurface colored by other data (SurfC, Surf3C), surface or isosurface transpared by other data (SurfA, Surf3A), tiles with variable size (TileS), mapping diagram (Map), STFA diagram (STFA). Surf3A and Surf3C have variants for automatic and manual selection of level values for isosurfaces. Each type of plotting has similar interface. There are 2 kind of versions which handle the arrays of data and coordinates or only single data array. Parameters of color scheme are specified by the string argument.

String paramter @var{sch} sets the color scheme (@pxref{Color scheme}). Previous color scheme is used by default. Arrays @var{x}, @var{y}, @var{z} can be vectors (not 3d arrays as @var{a}). If array @var{xdat}, @var{ydat}, @var{zdat} is not specified then its an automatic arrays are used with values equidistantly distributed along x, y, z.

@deffn {MGL command} surfc zdat cdat ['sch'='']
@deffnx {MGL command} surfc xdat ydat zdat cdat ['sch'='']
Draws surface specified parametrically @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@} and color it by matrix @var{cdat}[i,j]. See also @code{surf, surfa, surf3c}. @sref{SurfC sample}
@end deffn

@deffn {MGL command} surf3c adat cdat @code{val} ['sch'='']
@deffnx {MGL command} surf3c xdat ydat zdat adat cdat @code{val} ['sch'='']
Draws isosurface plot for 3d array specified parametrically @var{adat}[i,j,k](@var{xdat}[i,j,k], @var{ydat}[i,j,k], @var{zdat}[i,j,k]) at @var{a}(x,y,z)=@var{val}. It is mostly the same as @code{surf3} command but the color of isosurface depends on values of array @var{cdat}. If string contain @samp{#} then wire plot is produced. See also @code{surf3, sur3a, surfc}. @sref{Surf3C sample}
@end deffn

@deffn {MGL command} surf3c adat cdat ['sch'='' @code{num=5}]
@deffnx {MGL command} surf3c xdat ydat zdat adat cdat ['sch'='' @code{num=5}]
Draws @var{num}-th uniformly distributed in color range (see @code{caxis}) isosurfaces for 3d data specified parametrically.
@end deffn

@deffn {MGL command} surfa zdat cdat ['sch'='']
@deffnx {MGL command} surfa xdat ydat zdat cdat ['sch'='']
Draws surface specified parametrically @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@} and transparent it by matrix @var{cdat}[i,j]. See also @code{surf, surfc, surf3a, tile}. @sref{SurfA sample}
@end deffn

@deffn {MGL command} surf3a adat cdat @code{val} ['sch'='']
@deffnx {MGL command} surf3a xdat ydat zdat adat cdat @code{val} ['sch'='']
Draws isosurface plot for 3d array specified parametrically @var{adat}[i,j,k](@var{xdat}[i,j,k], @var{ydat}[i,j,k], @var{zdat}[i,j,k]) at @var{a}(x,y,z)=@var{val}. It is mostly the same as @code{surf3} command but the transparency of isosurface depends on values of array @var{cdat}. If string contain @samp{#} then wire plot is produced. See also @code{surf3, sur3c, surfa}. @sref{Surf3A sample}
@end deffn

@deffn {MGL command} surf3a adat cdat ['sch'='' @code{num=5}]
@deffnx {MGL command} surf3a xdat ydat zdat adat cdat ['sch'='' @code{num=5}]
Draws @var{num}-th uniformly distributed in color range (see @code{caxis}) isosurfaces for 3d data specified parametrically.
@end deffn

@deffn {MGL command} tile zdat rdat ['sch'='']
@deffnx {MGL command} tile xdat ydat zdat rdat ['sch'='']
Draws horizontal tiles for surface specified parametrically @{@var{xdat}[i,j], @var{ydat}[i,j], @var{zdat}[i,j]@}. It is mostly the same as @code{tile} but the size of tiles is determined by @var{rdat} array. See also @code{surfa, tile}. @sref{TileS sample}
@end deffn

@deffn {MGL command} map udat vdat ['sch'='' @code{pnts=on}]
@deffnx {MGL command} map xdat ydat udat vdat ['sch'='' @code{pnts=on}]
Draws mapping plot for matrixes @{@var{udat}, @var{vdat} @} which parametrically depend on coordinates @var{xdat}, @var{ydat}. The previous position of the cell (point) is marked by color. Height is proportional to Jacobian(udat,vdat). This plot is like Arnold diagram ???. If @code{pnts=off} then face is drawn otherwise the color ball at matrix knots are drawn. The size of @var{udat} and @var{vdat} must be the same. @sref{Map sample}
@end deffn

@deffn {MGL command} stfa re im @code{dn} ['sch'='' @code{pnts=on}]
@deffnx {MGL command} stfa xdat ydat re im @code{dn} ['sch'='' @code{pnts=on}]
Draws spectrogram of complex array @var{re}+i*@code{im} for Fourier size of @var{dn} points at plane @var{z=zVal}. Parameter @var{dn} is arbitrary even integer. For example in 1D case, result is density plot of data @math{res[i,j]=|\sum_d^dn exp(I*j*d)*(re[i*dn+d]+I*im[i*dn+d])|/dn} with size @{int(nx/dn), dn, ny@}.
@end deffn




@c ##################################################################
@node Vector fields (MGL), Other plotting (MGL), Dual plotting (MGL), MGL interface
@subsection Vector fields (MGL)
@cindex vectc
@cindex vect
@cindex flow
@cindex pipe
@cindex dew

These commands perform plotting of 2D and 3D vector fields. There are 5 generally different types of vector fields representations: simple vector field (Vect), vector field with coloring (VectC), vector field by dew-drops (Dew), flow threads (Flow), flow pipes (Pipe). Each type of plotting has similar interface. There are 2 kind of versions which handle the arrays of data and coordinates or only single data array. Parameters of color scheme are specified by the string argument. @xref{Color scheme}.

The color is specified by the string argument @var{sch}. Previous color scheme is used by default. The size of @var{udat}, @var{vdat} and @var{wdat} must be equal. The minor dimensions of arrays @var{xdat}, @var{ydat}, @var{zdat} and @var{udat} must be equal too. Arrays @var{xdat}, @var{ydat} and @var{zdat} can be vectors (not matrices as @var{udat}). The graphics is plotted for each z slice of @var{udat}, @var{vdat} for 2D case.

@deffn {MGL command} vect udat vdat ['sch'='' @code{zval=nan}]
@deffnx {MGL command} vect xdat ydat udat vdat ['sch'='' @code{zval=nan}]
Draws plane vector field plot for the field @{@var{udat}, @var{vdat}@} depending parametrically on coordinates @var{xdat}, @var{ydat} at level @var{z=zVal}. The length of hachures is proportional to @math{\sqrt@{udat^2+vdat^2@}}. The number of hachures depend on @var{meshnum}. See also @code{vectc, flow, pipe, dew}. @sref{Vect sample}
@end deffn

@deffn {MGL command} vect udat vdat wdat ['sch'='']
@deffnx {MGL command} vect xdat ydat zdat udat vdat wdat ['sch'='']
This is 3D version of the previous command. Here arrays @var{udat}, @var{vdat}, @var{wdat} must be 3-ranged tensors with equal sizes and the length of hachures is proportional to @math{\sqrt@{udat^2+vdat^2+wdat^2@}}. @sref{Vect 3D sample}
@end deffn

@deffn {MGL command} vectc udat vdat ['sch'='' @code{zval=nan}]
@deffnx {MGL command} vectc xdat ydat udat vdat ['sch'='' @code{zval=nan}]
Draws plane vector field plot for the field @{@var{udat}, @var{vdat}@} depending parametrically on coordinates @var{xdat}, @var{ydat} at level @var{z=zVal}. The color of hachures is proportional to @math{\sqrt@{udat^2+vdat^2@}}. The number of hachures depend on @var{meshnum}. See also @code{vect, flow, pipe, dew}. @sref{VectC sample}
@end deffn

@deffn {MGL command} vectc udat vdat wdat ['sch'='']
@deffnx {MGL command} vectc xdat ydat zdat udat vdat wdat ['sch'='']
This is 3D version of the previous command. Here arrays @var{udat}, @var{vdat}, @var{wdat} must be 3-ranged tensors with equal sizes and the color of hachures is proportional to @math{\sqrt@{udat^2+vdat^2+wdat^2@}}. @sref{VectC 3D sample}
@end deffn

@deffn {MGL command} dew udat vdat ['sch'='' @code{zval=nan}]
@deffnx {MGL command} dew xdat ydat udat vdat ['sch'='' @code{zval=nan}]
Draws dew-drops for plane vector field @{@var{udat}, @var{vdat}@} depending parametrically on coordinates @var{xdat}, @var{ydat} at level @var{z=zVal}. The color of drops is proportional to @math{\sqrt@{udat^2+vdat^2@}}. The number of drops depend on @var{meshnum}. Note that this is very expensive plot in memory usage and creation time! See also @code{vectc}. @sref{Dew sample}
@end deffn

@deffn {MGL command} flow udat vdat ['sch'='' @code{num=5 zval=nan}]
@deffnx {MGL command} flow xdat ydat udat vdat ['sch'='' @code{num=5 zval=nan}]
Draws plane flow threads for the vector field @{@var{udat}, @var{vdat}@} depending parametrically on coordinates @var{xdat}, @var{ydat} at level @var{z=zVal}. Number of threads is proportional to @var{num}. The color of lines is proportional to @math{\sqrt@{udat^2+vdat^2@}}. Warm color corresponds to normal flow (like attractor). Cold one corresponds to inverse flow (like source). See also @code{vect, vectc, pipe}. @sref{Flow sample}
@end deffn

@deffn {MGL command} flow udat vdat wdat ['sch'='' @code{num=3}]
@deffnx {MGL command} flow xdat ydat zdat udat vdat wdat ['sch'='' @code{num=3}]
This is 3D version of the previous command. Here arrays @var{udat}, @var{vdat}, @var{wdat} must be 3-ranged tensors with equal sizes and the color is proportional to @math{\sqrt@{udat^2+vdat^2+wdat^2@}}. @sref{Flow 3D sample}
@end deffn

@deffn {MGL command} pipe udat vdat ['sch'='' @code{r0=0.05 num=5 zval=nan}]
@deffnx {MGL command} pipe xdat ydat udat vdat ['sch'='' @code{r0=0.05 num=5 zval=nan}]
Draws plane flow pipes for the vector field @{@var{udat}, @var{vdat}@} depending parametrically on coordinates @var{xdat}, @var{ydat} at level @var{z=zVal}. Number of pipes is proportional to @var{num}. The color of pipes is proportional to @math{\sqrt@{udat^2+vdat^2@}}. Warm color corresponds to normal flow (like attractor). Cold one corresponds to inverse flow (like source). Parameter @var{r0} set the base pipe radius. If @var{r0}<0 then pipe radius is inverse proportional to amplitude. The size of @var{ax} and @var{ay} must be equal. See also @code{vect, vectc, pipe}. @sref{Flow sample}
@end deffn

@deffn {MGL command} pipe udat vdat wdat ['sch'='' @code{r0=0.05 num=3}]
@deffnx {MGL command} pipe xdat ydat zdat udat vdat wdat ['sch'='' @code{r0=0.05 num=3}]
This is 3D version of the previous command. Here arrays @var{udat}, @var{vdat}, @var{wdat} must be 3-ranged tensors with equal sizes and the color is proportional to @math{\sqrt@{udat^2+vdat^2+wdat^2@}}. @sref{Flow 3D sample}
@end deffn


@c ##################################################################
@node Other plotting (MGL), Nonlinear fitting (MGL), Vector fields (MGL), MGL interface
@subsection Other plotting (MGL)
@cindex cont[xyz]
@cindex dens[xyz]
@cindex contf[xyz]
@cindex dots
@cindex crust
@cindex triplot
@cindex fplot
@cindex fsurf


These commands perform miscelaneous plotting. There is unstructured data points plots (Dots), surface reconstruction (Crust), surfaces on the triangular mesh (TriPlot), textual formula plotting (Plots by formula), data plots at edges (Dens[XYZ], Cont[XYZ], ContF[XYZ]), simple plot (SimplePlot). Each type of plotting has similar interface. There are 2 kind of versions which handle the arrays of data and coordinates or only single data array. Parameters of color scheme are specified by the string argument. @xref{Color scheme}.

@deffn {MGL command} densx dat ['sch'='' @code{val=nan}]
@deffnx {MGL command} densy dat ['sch'='' @code{val=nan}]
@deffnx {MGL command} densz dat ['sch'='' @code{val=nan}]
These plotting commands draw density plot in x, y or z plain. If @var{dat} is a tensor (3-dimensional data) then interpolation to a given @var{val} is performed. These commands are useful for creating projections of the 3D data array to the bounding box. See also @code{cont[xyz], contf[xyz], dens}. @sref{Dens projection sample}
@end deffn

@deffn {MGL command} contx dat ['sch'='' @code{val=nan num=7}]
@deffnx {MGL command} conty dat ['sch'='' @code{val=nan num=7}]
@deffnx {MGL command} contz dat ['sch'='' @code{val=nan num=7}]
These plotting commands draw contour lines in x, y or z plain. If @var{dat} is a tensor (3-dimensional data) then interpolation to a given @var{val} is performed. These commands are useful for creating projections of the 3D data array to the bounding box. See also @code{dens[xyz], contf[xyz], cont}. @sref{Cont projection sample}
@end deffn

@deffn {MGL command} contfx dat ['sch'='' @code{val=nan num=7}]
@deffnx {MGL command} contfy dat ['sch'='' @code{val=nan num=7}]
@deffnx {MGL command} contfz dat ['sch'='' @code{val=nan num=7}]
These plotting commands draw solid contours in x, y or z plain. If @var{dat} is a tensor (3-dimensional data) then interpolation to a given @var{val} is performed. These commands are useful for creating projections of the 3D data array to the bounding box. See also @code{dens[xyz], cont[xyz], contf}.
@end deffn

@deffn {MGL command} dots xdat ydat zdat ['sch'='']
Draws the arbitrary placed points @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@}. See also @code{crust, mark, plot}. @sref{Dots sample}
@end deffn

@deffn {MGL command} crust xdat ydat zdat ['sch'='']
Reconstructs and draws the surface for arbitrary placed points @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@}. If string contain @samp{#} then wire plot is produced. See also @code{dots, triplot}. @sref{Crust sample}
@end deffn

@deffn {MGL command} triplot xdat ydat idat ['sch'='' @code{zval=nan}]
@deffnx {MGL command} triplot xdat ydat zdat idat ['sch'='' @code{zval=nan}]
Draws the surface of triangles. Triangle vertexes are set by indexes @var{idat} of data points @{@var{xdat}[i], @var{ydat}[i], @var{zdat}[i]@}. If string contain @samp{#} then wire plot is produced. First dimensions of @var{idat} must be 3 or greater. See also @code{dots, crust}.
@end deffn

@deffn {MGL command} fplot 'y(x)' ['pen'='' @code{zval=nan num=100}]
Draws command function @samp{y(x)} at plane z=@var{zval} where @samp{x} variable is changed in @code{xrange}. You do not need to create the data arrays to plot it. The parameter @var{num} set the minimal number of points along coordinate(s) for plots. See also @code{plot}.
@end deffn

@deffn {MGL command} fplot 'x(t)' 'y(t)' 'z(t)' ['pen'='' @code{num=100}]
Draws command parametrical curve @{@samp{x(t)}, @samp{y(t)}, @samp{z(t)}@} where @samp{t} variable is changed in range [0, 1]. You do not need to create the data arrays to plot it. The parameter @var{num} set the minimal number of points along coordinate(s) for plots. See also @code{plot}.
@end deffn

@deffn {MGL command} fsurf 'z(x,y)' ['sch'='' @code{num=100}]
Draws command surface for function @samp{z(x,y)} where @samp{x}, @samp{y} variable are changed in @code{xrange, yrange}. You do not need to create the data arrays to plot it. The parameter @var{num} set the minimal number of points along coordinate(s) for plots. See also @code{surf}.
@end deffn

@deffn {MGL command} fsurf 'x(u,v)' 'y(u,v)' 'z(u,v)' ['sch'='' @code{num=100}]
Draws command parametrical surface @{@samp{x(u,v)}, @samp{y(u,v)}, @samp{z(u,v)}@} where @samp{u}, @samp{v} variable are changed in range [0, 1]. You do not need to create the data arrays to plot it. The parameter @var{num} set the minimal number of points along coordinate(s) for plots. See also @code{surf}.
@end deffn


@c ##################################################################
@node Nonlinear fitting (MGL), Data create (MGL), Other plotting (MGL), MGL interface
@subsection Nonlinear fitting (MGL)
@cindex fit
@cindex fits
@cindex putsfit

These commands fit data to formula. Fitting goal is to find formula parameters for the best fit the data points, i.e. to minimize the sum @math{\sum_i (f(x_i, y_i, z_i) - a_i)^2/s_i^2}. At this, approximation command @samp{f} can depend only on one argument @samp{x} (1D case), on two arguments @samp{x,y} (2D case) and on three arguments @samp{x,y,z} (3D case). The command @samp{f} also may depend on parameters. Normally the list of fitted parameters is specified by @var{var} string (like, @samp{abcd}). Usually user should supply initial values for fitted parameters by @var{ini} variable. But if he/she don't supply it then the zeros are used.

Commands @code{fit} and @code{fits} do not draw the obtained data themselves. They fill the data @var{out} by formula @samp{f} with found coefficients. At this, the @samp{x,y,z} coordinates are equidistantly distributed in the bounding box. Number of points in @var{out} is selected as maximal value of @var{out} size or 100. Also you may print the last formula with found coefficients by @code{putsfit} command. @sref{Fitting sample}

The dimensions of arrays must be at least the same as the number of specified arrays @var{xdat}, @var{ydat}, @var{zdat}. Also the fitting only along specified directions will be performed (for example, along x and y if only @var{xdat} and @var{ydat} are specified). If array @var{xdat} is not specified then its an automatic array is used with values equidistantly distributed along x.


@deffn {MGL command} fits adat sdat 'func' 'var' [ini=0]
@deffnx {MGL command} fits xdat adat sdat 'func' 'var' [ini=0]
@deffnx {MGL command} fits xdat ydat adat sdat 'func' 'var' [ini=0]
@deffnx {MGL command} fits xdat ydat zdat adat sdat 'func' 'var' [ini=0]
Fit data along x-, y- and z-directions for 1d-,2d- or 3d array specified parametrically @var{adat}[i,j,k](@var{xdat}[i,j,k], @var{ydat}[i,j,k], @var{zdat}[i,j,k]) with weight factor @var{sdat}[i,j,k].
@end deffn

@deffn {MGL command} fit adat 'func' 'var' [ini=0]
@deffnx {MGL command} fit xdat adat 'func' 'var' [ini=0]
@deffnx {MGL command} fit xdat ydat adat 'func' 'var' [ini=0]
@deffnx {MGL command} fit xdat ydat zdat adat 'func' 'var' [ini=0]
Fit data along x-, y- and z-directions for 1d-,2d- or 3d array specified parametrically @var{adat}[i,j,k](@var{xdat}[i,j,k], @var{ydat}[i,j,k], @var{zdat}[i,j,k]) with weight factor =1.
@end deffn

@deffn {MGL command} putsfit @code{x y} ['pre'='' 'fnt'='' @code{size=-1}]
Print last fitted formula with found coefficients (as numbers) at position @{@var{x}, @var{y}@}. The string @var{pre} will be printed before formula. All other parameters are the same as in @ref{Text printing (MGL)}.
@end deffn


@c ##################################################################
@node Data create (MGL), Data filling (MGL), Nonlinear fitting (MGL), MGL interface
@subsection Data create (MGL)
@cindex new
@cindex var
@cindex list
@cindex delete
@cindex copy
@cindex column
@cindex set_id

@deffn {MGL command} new dat [@code{nx=1 ny=1 nz=1}]
Creates or recreates the array @var{dat} with specified size and fills it by zero. This command does nothing if one of parameters @var{nx}, @var{ny}, @var{nz} is zero or negative.
@end deffn

@deffn {MGL command} var dat @code{num v1 [v2=nan]}
Creates new variable with name dat for one-dimensional array of size num. Array elements are equidistantly distributed in range [@var{v1}, @var{v2}]. If @var{v2}=@code{nan} then @var{v2=v1} is used. 
@end deffn

@deffn {MGL command} list dat @code{v1 ...}
Creates new variable with name @var{dat} and fills it by numeric values of command arguments @code{v1 ...}. Command can create one-dimensional and two-dimensional arrays with arbitrary values. For creating 2d array the user should use delimiter - which means that the following values lie in next row. Array sizes are [maximal of row sizes * number of rows]. For example, command @code{list 1 | 2 3} creates the array [1 0; 2 3]. Note, that the maximal number of arguments is 1000. 
@end deffn

@deffn {MGL command} list dat d1 ...
Creates new variable with name @var{dat} and fills it by data values of arrays of command arguments @var{d1 ...}. Command can create two-dimensional or three-dimensional (if arrays in arguments are 2d arrays) arrays with arbitrary values. Minor dimensions of all arrays in arguments should be equal to dimensions of first array d1. In the opposite case the argument will be ignored. Note, that the maximal number of arguments is 1000. 
@end deffn

@deffn {MGL command} copy dat1 dat2
Creates new variable with name @var{dat1} and fills it by data values of array @var{dat2}.
@end deffn

@deffn {MGL command} delete dat
Deletes variable @var{dat} and makes its memory free. Can be useful for huge data arrays.
@end deffn

@deffn {MGL command} set_id dat 'ids'
Set the symbol id for data columns. The string must contain one symbol 'a'...'z' per column (without spaces).
@end deffn

@deffn {MGL command} info dat [@code{detail=off}]
Display information (sizes, maximum/minimum, momentums and so on) about the data dat. Show brief information by default (if @code{detail=off}).
@end deffn

@c ------------------------------------------------------------------
@node Data filling (MGL), Rearrange data (MGL), Data create (MGL), MGL interface
@subsection Data filling (MGL)
@cindex fill
@cindex modify

@deffn {MGL command} fill dat v1 v2 ['dir'='x']
Equidistantly fills the data values to range [@var{x1}, @var{x2}] in direction @var{dir}=@{@samp{x},@samp{y},@samp{z}@}.
@end deffn

@deffn {MGL command} fill dat 'eq' [vdat=0 wdat=0]
Command fills the value of array according to the formula in string @var{eq}. Formula is an arbitrary expression depending  on variables @samp{x}, @samp{y}, @samp{z}, @samp{u}, @samp{v}, @samp{w}. Coordinates @samp{x}, @samp{y}, @samp{z} are supposed to be normalized in @emph{bounding box} (in difference from @code{modify} commands). Variable @samp{u} is the original value of the array. Variables @samp{v} and @samp{w} are values of @var{vdat}, @var{wdat}.
@end deffn

@deffn {MGL command} modify dat 'eq' [@code{dim=0}]
Command fills the value of array according to the formula in string @var{eq}. Formula is an arbitrary expression depending  on variables @samp{x}, @samp{y}, @samp{z}, @samp{u}. Coordinates @samp{x}, @samp{y}, @samp{z} are supposed to be normalized in interval [0,1]. Variable @samp{u} is the original value of the array. Modification will be fulfilled only for slices >=@var{dim}.
@end deffn

@deffn {MGL command} modify dat 'eq' vdat [wdat=0]
Command fills the value of array according to the formula in string @var{eq}. Formula is an arbitrary expression depending  on variables @samp{x}, @samp{y}, @samp{z}, @samp{u}, @samp{v}, @samp{w}. Coordinates @samp{x}, @samp{y}, @samp{z} are supposed to be normalized in interval [0,1]. Variable @samp{u} is the original value of the array. Variables @samp{v} and @samp{w} are values of @var{vdat}, @var{wdat}.
@end deffn

@c ------------------------------------------------------------------
@node Rearrange data (MGL), File I/O (MGL), Data filling (MGL), MGL interface
@subsection Rearrange data (MGL)
@cindex rearrange
@cindex extend
@cindex transpose
@cindex squeeze
@cindex crop

@deffn {MGL command} rearrange dat @code{mx [my=0 mz=0]}
Rearrange dimensions without changing data array so that resulting sizes should  be @var{mx}*@var{my}*@var{mz} < nx*ny*nz. If some of parameter @var{my} or @var{mz} are zero then it will be selected to optimal fill of data array. For example, if @var{my}=0 then it will be change to @var{my}=nx*ny*nz/@var{mx} and @var{mz} will be 1.
@end deffn

@deffn {MGL command} extend dat @code{n1 [n2=0]}
Increase the dimensions of the data by inserting new (|@var{n1}|+1)-th slices after (for @var{n1}>0) or before (for @var{n1}<0) of existed one. It is possible to insert 2 dimensions simultaneously for 1d data by using parameter @var{n2}. Data to new slices is copy from existed one. For example, for @var{n1}>0 new array will be 
@iftex
@math{a_{ij}^{new} = a_i^{old}} where j=0...@var{n1}. Correspondingly, for @var{n1}<0 new array will be @math{a_{ij}^{new} = a_j^{old}} where i=0...|@var{n1}|.
@end iftex
@ifnottex
a_ij^new = a_i^old where j=0...@var{n1}. Correspondingly, for @var{n1}<0 new array will be a_ij^new = a_j^old where i=0...|@var{n1}|.
@end ifnottex
@end deffn

@deffn {MGL command} transpose dat ['dim'='yxz']
Transposes (shift order of) dimensions of the data. New order of dimensions is specified int string @var{dim}. This command may be useful also for the reading of one-dimensional data.
@end deffn

@deffn {MGL command} squeeze dat, @code{rx [ry=1 rz=1]}
Reduces the data size by excluding data elements which indexes are not divisible by @var{rx}, @var{ry}, @var{rz} correspondingly.
@end deffn

@deffn {MGL command} crop dat @code{n1 n2} 'dir'
Cuts off edges @var{i}<@var{n1} and @var{i}>@var{n2} of the data along direction @var{dir}.
@end deffn

@c ------------------------------------------------------------------
@node File I/O (MGL), Make another data (MGL), Rearrange data (MGL), MGL interface
@subsection File I/O (MGL)
@cindex read
@cindex readhdf
@cindex readmat
@cindex readall
@cindex save
@cindex savehdf
@cindex export
@cindex import

@deffn {MGL command} read dat 'fname'
Reads data from tab-separated text file with auto determining sizes of the data.
@end deffn

@deffn {MGL command} read dat 'fname' @code{mx [my=1 mz=1]}
Reads data from text file with specified data sizes. This command does nothing if one of parameters @var{mx}, @var{my} or @var{mz} is zero or negative.
@end deffn

@deffn {MGL command} readmat dat 'fname' [@code{dim=2}]
Read data from text file with size specified at beginning of the file by first @var{dim} numbers. At this, variable @var{dim} set data dimensions.
@end deffn

@deffn {MGL command} readall dat 'templ' @code{v1 v2 [dv=1 slice=off]}
Join data arrays from several text files. The file names are determined by function call @code{sprintf(fname,templ,val);}, where @var{val} changes from @var{v1} to @var{v2} with step @var{dv}. The data load one-by-one in the same slice if @var{slice}=@code{off} or as slice-by-slice if @var{slice}=@code{on}.
@end deffn

@deffn {MGL command} readall dat 'templ' @code{[slice=off]}
Join data arrays from several text files which filenames satisfied the template @var{templ} (for example, @var{templ}=@code{"t_*.dat"}). The data load one-by-one in the same slice if @var{slice}=@code{off} or as slice-by-slice if @var{slice}=@code{on}.
@end deffn

@deffn {MGL command} save dat 'fname'
Saves the whole data array to tab-separated text file.
@end deffn

@deffn {MGL command} readhdf dat 'fname' 'dname'
Reads data array named @var{dname} from HDF file @var{fname}.
@end deffn
@deffn {MGL command} savehdf dat 'fname' 'dname'
Saves data array named @var{dname} from HDF file @var{fname}.
@end deffn

@deffn {MGL command} import dat 'fname' 'sch' [@code{v1=0 v2=1}]
Reads data from bitmap file. The RGB values of bitmap pixels are transformed to float values in range [@var{v1}, @var{v2}] using color scheme @var{sch} (@pxref{Color scheme}).
@end deffn

@deffn {MGL command} export dat 'fname' 'sch' [@code{v1=0 v2=0}]
Saves data matrix to bitmap file. The data values are transformed from range [@var{v1}, @var{v2}] to RGB pixels of bitmap using color scheme @var{sch} (@pxref{Color scheme}). If @var{v1}>=@var{v2} then the values of @var{v1}, @var{v2} are automatically determined as minimal and maximal value of the data array.
@end deffn

@c ------------------------------------------------------------------
@node Make another data (MGL), Commands on direction (MGL), File I/O (MGL), MGL interface
@subsection Make another data (MGL)
@cindex subdata
@cindex hist
@cindex momentum
@cindex sum
@cindex max
@cindex min
@cindex combine
@cindex evaluate
@cindex resize

@deffn {MGL command} combine res adat bdat
Returns direct multiplication of arrays (like, res[i,j] = adat[i]*bdat[j] and so on).
@end deffn

@deffn {MGL command} evaluate res dat idat [@code{norm=on}]
@deffnx {MGL command} evaluate res dat idat jdat [@code{norm=on}]
@deffnx {MGL command} evaluate res dat idat jdat kdat [@code{norm=on}]
Get array which values is result of interpolation of original array for coordinates from other arrays. All dimensions must be the same for data @var{idat}, @var{jdat}, @var{kdat}. Coordinates from @var{idat}, @var{jdat}, @var{kdat} are supposed to be normalized in range [0,1] (if @var{norm}=@code{true}) or in range [0,nx], [0,ny], [0,nz] correspondingly.
@end deffn

@deffn {MGL command} hist res dat @code{num v1 v2}
@deffnx {MGL command} hist res dat wdat @code{num v1 v2}
Creates @var{num}-th points distribution @var{res} of the data values of @var{dat} in range [@var{v1}, @var{v2}]. Array @var{wdat} specifies weights of the data elements (all weight is 1 if @var{wdat} is not specified).
@end deffn

@deffn {MGL command} momentum res dat 'how' ['dir'='z']
Get momentum (1D-array) of the data along direction @var{dir}. String @var{how} contain kind of momentum and may looks like @code{"x1"} for median 
@iftex
@math{\sum_{ij} x_i a_{ij}} in x-direction, @code{"y2"} for @math{\sum_{ij} y_j^2 a_{ij}}
@end iftex
@ifnottex
\sum_ij x_i a_ij in x-direction, @code{"y2"} for \sum_ij y_j^2 a_ij
@end ifnottex
in x-dir and so on. Mixed momentum (like @code{"xy"}) are not supported now.
@end deffn

@deffn {MGL command} sum res dat 'dir'
Gets array which is the result of summation in given direction or direction(s).
@end deffn
@deffn {MGL command} max res dat 'dir'
Gets array which is the maximal data values in given direction or direction(s).
@end deffn
@deffn {MGL command} min res dat 'dir'
Gets array which is the minimal data values in given direction or direction(s).
@end deffn

@deffn {MGL command} resize res dat @code{mx [my=1 mz=1]}
Makes array @var{res} of sizes @var{mx}, @var{my}, @var{mz} with interpolated data of array @var{dat}. 
@end deffn

@deffn {MGL command} subdata res dat @code{xx [yy=: zz=:]}
Extracts sub-array data @var{res} from the original data @var{dat} array keeping fixed positive index. For example @code{subdata a b : 2} extracts 3d row (indexes are zero based), @code{subdata a b 4 :} extracts 5th column, @code{subdata a b : : 3} extracts 4th slice and so on. Note that symbol @samp{:} is defined @samp{:}=@code{-1} in MGL.
@end deffn

@deffn {MGL command} transform dat 'type' real imag
Do integral transformation of complex data @var{real}, @var{imag} on specified direction. Now only Fourier transformation is supported. The order of transformations is specified in string @var{type}: first character for x-dimension, second one for y-dimension, third one for z-dimension. The possible character are: @samp{f} is forward Fourier transformation, @samp{i} is inverse Fourier transformation, @samp{n} or @samp{ } is no transformation.
@end deffn

@deffn {MGL command} transforma dat 'type' ampl phase
Do integral transformation of complex data @var{ampl}, @var{phase} on specified direction. Now only Fourier transformation is supported. The order of transformations is specified in string @var{type}: first character for x-dimension, second one for y-dimension, third one for z-dimension. The possible character are: @samp{f} is forward Fourier transformation, @samp{i} is inverse Fourier transformation, @samp{n} or @samp{ } is no transformation.
@end deffn

@deffn {MGL command} stfad res real imag @code{dn} ['dir'='x']
Short time fourier analysis for real and imaginary parts. Output  is amplitude of partial fourier of length @var{dn}. For example if @var{dir}=@samp{x}, result will have size @{int(nx/dn), dn, ny@} and it will contain @math{res[i,j,k]=|\sum_d^dn exp(I*j*d)*(real[i*dn+d,k]+I*imag[i*dn+d,k])|/dn}.
@end deffn

@deffn {MGL command} pde res 'ham' ini_re ini_im [@code{dz=0.1 k0=100}]
Solves equation du/dz = i*k0*@var{ham}(p,q,x,y,z,|u|)[u], where p=-i/k0*d/dx, q=-i/k0*d/dy are pseudodifferential operators. Parameters @var{ini_re}, @var{ini_im} specify real and imaginary part of initial field distribution. Coordinates of the equation (and the solution) are supposed to be in the bounding box. Note that really this ranges are increased by factor 3/2 for purpose of reducing reflection from boundaries. Parameter @var{dz} set the step along evolutionary coordinate z. At this moment, simplified form of function @var{ham} is supported -- all ``mixed'' terms (like @samp{x*p}->x*d/dx) are excluded. For example, in 2D case this function is effectively @math{ham = f(p,z) + g(x,z,u)}. However commutable combinations (like @samp{x*q}->x*d/dy) are allowed. Here variable @samp{u} is used for |u|. This allow one solve nonlinear problems -- for example, for nonlinear Shrodinger equation you may set @code{ham='p^2+q^2-u^2'}. You may specify imaginary part for wave absorption, like @code{ham = 'p^2+i*x*(x>0)'}, but only if dependence on variable @samp{i} is linear (i.e. @math{ham = hre+i*him}).
@end deffn

@deffn {MGL command} ray res 'ham' @code{x0 y0 z0 p0 q0 v0 [dt=0.1 tmax=10]}
Solves GO ray equation like d@emph{r}/dt = d @var{ham}/d@emph{p}, d@emph{p}/dt = -d @var{ham}/d@emph{r}. This is Hamiltonian equations for particle trajectory in 3D case. Here @var{ham} is Hamiltonian which may depend on coordiantes @samp{x}, @samp{y}, @samp{z}, momentums @samp{p}=px, @samp{q}=py, @samp{v}=pz and time @samp{t}: @math{ham = H(x,y,z,p,q,v,t)}. The starting point (at @code{t=0}) is defined by variables @{@var{x0}, @var{y0}, @var{z0}, @var{p0}, @var{q0}, @var{v0}@}. Parameters @var{dt} and @var{tmax} specify the integration step and maximal time for ray tracing. Result is array of @{x,y,z,p,q,v,t@} with dimensions @{7 * int(@var{tmax}/@var{dt}+1) @}.
@end deffn


@c ------------------------------------------------------------------
@node Commands on direction (MGL), Operators (MGL), Make another data (MGL), MGL interface
@subsection Commands on direction (MGL)
@cindex cumsum
@cindex integral
@cindex diff
@cindex diff2
@cindex swap
@cindex mirror
@cindex sew
@cindex smooth
@cindex envelop
@cindex norm
@cindex normsl

These commands change the data in some direction like differentiations, integrations and so on. The direction in which the change will applied is specified by the string parameter, which may contain @samp{x}, @samp{y} or @samp{z} characters for 1-st, 2-nd and 3-d dimension correspondengly.

@deffn {MGL command} cumsum dat 'dir'
Cumulative summation of the data in given direction or directions.
@end deffn
@deffn {MGL command} integrate dat 'dir'
Integrates (like cumulative summation) the data in given direction or directions.
@end deffn
@deffn {MGL command} diff dat 'dir'
Differentiates the data in given direction or directions.
@end deffn
@deffn {MGL command} diff2 dat 'dir'
Double-differentiates (like Laplace operator) the data in given direction.
@end deffn
@deffn {MGL command} swap dat 'dir'
Swaps the left and right part of the data in given direction (useful for Fourier spectrum).
@end deffn
@deffn {MGL command} mirror dat 'dir'
Mirror the left-to-right part of the data in given direction. Looks like change the value index @var{i}->@var{n-i}.
@end deffn

@deffn {MGL command} sew dat ['dir'='xyz' @code{da=2*pi}]
Remove value steps (like phase jumps after inverse trigonometric commands) with period @var{da} in given direction.
@end deffn
@deffn {MGL command} smooth data @code{type} ['dir'='xyz']
Smooths the data on specified direction or directions by method @var{Type}. Now 4 methods are supported: @samp{0} does nothing, @samp{1} linear averaging by 3 points, @samp{2} linear averaging by 5 points, @samp{3} quadratic averaging by 5 points.
@end deffn

@deffn {MGL command} envelop dat ['dir'='x']
Find envelop for data values along direction @var{dir}. Only one direction can be specified at once.
@end deffn

@deffn {MGL command} normsl dat @code{v1 v2} ['dir'='z' @code{keep=on sym=off}]
Normalizes data slice-by-slice along direction @var{dir} the data in slices to range [@var{v1},@var{v2}]. If flag @var{sym}=@code{on} then symmetrical interval [-max(|v1|,|v2|), max(|v1|,|v2|)] is used. If @var{keep} is set then maximal value of k-th slice will be limited by 
@iftex
@math{\sqrt{\sum a_{ij}(k)/\sum a_{ij}(0)}}.
@end iftex
@ifnottex
@math{\sqrt@{\sum a_ij(k)/\sum a_ij(0)@}}.
@end ifnottex
@end deffn

@deffn {MGL command} norm dat @code{v1 v2 [sym=off dim=0]}
Normalizes the data to range [@var{v1},@var{v2}]. If flag @var{sym}=@code{on} then symmetrical interval [-max(|v1|,|v2|), max(|v1|,|v2|)] is used. Modification will be applied only for slices >=@var{dim}.
@end deffn


@c ------------------------------------------------------------------
@node Operators (MGL), Program flow (MGL), Commands on direction (MGL), MGL interface
@subsection Operators (MGL)
@cindex multo
@cindex addto
@cindex divto
@cindex subto

@deffn {MGL command} multo dat dat2
Multiplies the data by the other one for each element.
@end deffn
@deffn {MGL command} divto dat dat2
Divides the data by the other one for each element.
@end deffn
@deffn {MGL command} addto dat dat2
Adds the other data.
@end deffn
@deffn {MGL command} subto dat dat2
Subtracts the other data.
@end deffn
@deffn {MGL command} multo dat @code{val}
Multiplies each element by the number.
@end deffn
@deffn {MGL command} divto dat @code{val}
Divides each element by the number.
@end deffn
@deffn {MGL command} addto dat @code{val}
Adds the number to each element.
@end deffn
@deffn {MGL command} subto dat @code{val}
Subtracts the number to each element.
@end deffn

@c ------------------------------------------------------------------
@node Program flow (MGL), Command options (MGL), Operators (MGL), MGL interface
@subsection Program flow (MGL)
@cindex call
@cindex chdir
@cindex define
@cindex if
@cindex elseif
@cindex else
@cindex endif
@cindex for
@cindex next
@cindex once
@cindex stop

These commands control program flow, like, conditions, cycles, define script arguments and so on.

@deffn {MGL command} call 'fname'
Executes script @var{fname}.
@end deffn
@deffn {MGL command} chdir 'path'
Changes the current directory to @var{path}.
@end deffn
@deffn {MGL command} define $N smth
Sets @var{N}-th script argument to @var{smth}. Note, that @var{smth} is used as is (with @samp{'} symbols if present).
@end deffn
@deffn {MGL command} if dat 'cond'
Starts block which will be executed if @var{dat} satisfy to @var{cond}.
@end deffn
@deffn {MGL command} if @code{val}
Starts block which will be executed if @code{val} is nonzero.
@end deffn
@deffn {MGL command} elseif dat 'cond'
Starts block which will be executed if previous @code{if} or @code{elseif} is false and @var{dat} satisfy to @var{cond}.
@end deffn
@deffn {MGL command} elseif @code{val}
Starts block which will be executed if previous @code{if} or @code{elseif} is false and @code{val} is nonzero.
@end deffn
@deffn {MGL command} else
Starts block which will be executed if previous @code{if} or @code{elseif} is false.
@end deffn
@deffn {MGL command} endif
Finishes @code{if/elseif/else} block.
@end deffn
@deffn {MGL command} for $N @code{v1 v2 [dv=1]}
Starts cycle with @var{N}-th argument changing from @var{v1} to @var{v2} with the step @var{dv}.
@end deffn
@deffn {MGL command} for $N dat
Starts cycle with @var{N}-th argument changing for @var{dat} values.
@end deffn
@deffn {MGL command} next
Finishes @code{for} cycle.
@end deffn
@deffn {MGL command} once @code{val}
The code between once on and once off will be executed only once. Useful for large data manipulation in programs like UDAV.
@end deffn
@deffn {MGL command} stop
Terminate execution.
@end deffn

@c ------------------------------------------------------------------
@node  Command options (MGL), Suffixes, Program flow (MGL), MGL interface
@subsection Command options (MGL)
@cindex alpha
@cindex alphadef
@cindex xrange
@cindex yrange
@cindex zrange
@cindex crange
@cindex cut
@cindex ambient
@cindex fontsize
@cindex marksize
@cindex meshnum
@cindex legend

Command options allow the easy setup of the plot by changing of global settings only for this plot. Options are specified at the end of string. Each option is separated from the previous text by symbol @samp{;}. Options work so that them remember the current settings, change settings as it being set in the option, execute command and return the original settings back. So, the options usage for data handling commands or for graphics setup commands is useless.

The most useful options are @code{xrange, yrange, zrange}. They sets the boundaries for data change. This boundaries are used for automatically filled variables. So, these options allow one to change the position of some plots. For example, in command @code{plot y; xrange 0.1 0.9} the x coordinate will be equidistantly distributed in range 0.1 ... 0.9.

The full list of options are:
@deffn {MGL command} alpha @code{val}
Sets alpha value (transparency) of the plot. The value should be in range [0, 1].
@end deffn
@deffn {MGL command} alphadef @code{val}
Sets alpha value (transparency) of the plot. The value should be in range [0, 1].
@end deffn
@deffn {MGL command} ambient @code{val}
Sets brightness of ambient light for the plot. The value should be in range [0, 1].
@end deffn
@deffn {MGL command} crange @code{val1 val2}
Sets boundaries of color change for the plot.
@end deffn
@deffn {MGL command} xrange @code{val1 val2}
Sets boundaries of x coordinate change for the plot.
@end deffn
@deffn {MGL command} yrange @code{val1 val2}
Sets boundaries of y coordinate change for the plot.
@end deffn
@deffn {MGL command} zrange @code{val1 val2}
Sets boundaries of z coordinate change for the plot.
@end deffn
@deffn {MGL command} cut @code{val}
Sets whether to cut or to project the plot points lying outside the bounding box.
@end deffn
@deffn {MGL command} fontsize @code{val}
Sets the size of text.
@end deffn
@deffn {MGL command} marksize @code{val}
Sets the size of marks.
@end deffn
@deffn {MGL command} meshnum @code{val}
Work like @code{meshnum} command.
@end deffn
@deffn {MGL command} legend 'txt'
Adds string 'txt' to internal legend accumulator. The style of described line and mark is taken from arguments of the plot command. The maximal number of entries is 100.
@end deffn

@c ------------------------------------------------------------------
@node  Suffixes, , Command options (MGL), MGL interface
@subsection Suffixes for variable

Suffixes can get some numerical value (like its size, maximal or minimal value, the sum of elements and so on) of the data array in variable and use it later as usual number in command arguments. The suffixes start from point @samp{.} right after (without spaces) variable name or its subarray. For example, @code{a.nx} give the x-size of data a, @code{b(1).max} give maximal value of second row of variable b, @code{c(:,0).sum} give sum of element in first column of c and so on.

The full list of suffixes are:
@table @strong
@item nx, ny, nz
Give the data size in x-, y-, z-direction correspondingly.
@item max
Give maximal value of the data.
@item min
Give minimal value of the data.
@item mx, my, mz
Give x-, y-, z-position of data maximum.
@item ax, ay, az, aa
Give x-, y-, z-position of data mass center or average data value.
@item wx, wy, wz, wa
Give width in x-, y-, z-direction or data dispersion value.
@item sx, sy, sz, sa
Give skewness in x-, y-, z-direction or data skewness value.
@item kx, ky, kz, ka
Give kurtosis in x-, y-, z-direction or data kurtosis value.
@item sum
Give sum of data values.
@item a
Give first value of data array.
@item fst
Give first nonzero value of data array.
@item lst
Give last nonzero value of data array.
@end table
